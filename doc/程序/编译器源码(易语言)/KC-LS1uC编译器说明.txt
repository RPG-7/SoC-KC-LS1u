
1.编译器说明.

打开编译器,点击"打开"按钮,编译器会把根目录的"main.c"文件调入;
点击"编译"按钮,调入的程序文件被编译并生成二进制bin文件,并保存当前显示的文本到程序文件;
点击"保存"按钮,当前显示的文本会被保存到程序文件;







2.编译出的二进制文件说明.


编译完成后,编译器会在根目录生成3类二进制文件,如下;



第1类,被分割为最大256K的二进制文件:

CPU的指令是16位,上电的时候CPU是从0地址开始取指令运行;

KC-LS1u_EPROM这层PCB上的8片27C020和程序物理地址的关系:

"U4" 和 "U8" 地址范围000000H~03FFFFH, "U4" 是高8位指令存储器, "U8" 是低8位指令存储器;
"U3" 和 "U7" 地址范围040000H~07FFFFH, "U3" 是高8位指令存储器, "U7" 是低8位指令存储器;
"U2" 和 "U6" 地址范围080000H~0BFFFFH, "U2" 是高8位指令存储器, "U6" 是低8位指令存储器;
"U1" 和 "U5" 地址范围0C0000H~0FFFFFH, "U1" 是高8位指令存储器, "U5" 是低8位指令存储器;

编译器生成的 "ROM_U4.bin" 和 "ROM_U8.bin" 烧入27C020芯片后,分别插"U4" 和 "U8"位置;
程序超过256K后,编译器会多生成 "ROM_U3.bin" 和 "ROM_U7.bin"文件, 烧入芯片后,分别插"U3" 和 "U7"位置;
程序超过512K后,编译器会多生成 "ROM_U2.bin" 和 "ROM_U6.bin"文件, 烧入芯片后,分别插"U2" 和 "U6"位置;
程序超过768K后,编译器会多生成 "ROM_U1.bin" 和 "ROM_U5.bin"文件, 烧入芯片后,分别插"U1" 和 "U5"位置;
程序超过1024K后,编译器不会再生成多余文件;



第2类,没有被分割的二进制文件:

编译器生成的 "ROM_H.bin" 和 "ROM_L.bin" 分别为高8位指令存储器和低8位指令存储器二进制文件;



第3类,合并的二进制文件:

编译器生成的 "ROM.bin" 是把 "ROM_L.bin" 和 "ROM_H.bin" 合并在一起形成的一个文件;
"ROM.bin" 文件的上半部分是 "ROM_L.bin" 的内容,下半部分是 "ROM_H.bin" 的内容;
需要在内存卡或硬盘上读取程序装入内存运行的时候, 使用 "ROM.bin" ;













3.编译器支持参数:


支持全局变量、局部变量、函数、头文件、字符串替换命令, "//" 和"/**/"两种注释.


(1).支持数据类型. 

signed可以省略，会默认为有符号数; 
char占1个字节,int占2个字节,long int占4个字节, 指针占3个字节. 

signed char 
signed int 
signed long int 
unsigned char 
unsigned int 
unsigned long int 

signed char* 
signed int* 
signed long int* 
unsigned char* 
unsigned int* 
unsigned long int* 

signed char 一维数组 
signed int 一维数组 
signed long int 一维数组 
unsigned char 一维数组 
unsigned int 一维数组 
unsigned long int 一维数组 

16进制常量 
10进制常量 
8进制常量 
字符常量 


变量的物理地址定义方式. 
@0xc00000 char a,b;@ 
意思是修改当前变量的分配地址为0xc00000,然后变量a的地址就是0xc00000,b的地址是0xc00001, 然后遇到第2个"@"分配地址会恢复,否则会一直加下去.... 




(2).支持函数类型. 

signed可以省略，会默认为有符号数. 
char返回1个字节,int返回2个字节,long int返回4个字节, 指针返回3个字节. 

void 

signed char 
signed int 
signed long int 
unsigned char 
unsigned int 
unsigned long int 

signed char* 
signed int* 
signed long int* 
unsigned char* 
unsigned int* 
unsigned long int* 

注意 : 一个函数固定占用3个字节内存,用于存放程序返回地址;


(3).支持控制语句. 

if - else 
if - else if - else if - else if ...... 
while 
do - while 
for 
goto 
break 
continue 
return 
rom_run 

特殊控制语句 "rom_run" . 
本机有两组ROM, 不管CPU当前执行的程序在哪个ROM，只要执行到rom_run后,程序就会跳转到ROM地址000004H执行ROM切换指令,
然后切换到另一组ROM的000009H地址开始运行; 



(4).支持运算符(表达式里的运算符严格按照C优先级处理). 

sizeof 
() 
[] 
 + 
 - 
 * 
 / 
 % 
 & 
 | 
 ~ 
 ^ 
 ! 
 > 
 < 
 >= 
 <= 
 == 
 != 
 ++ 
 -- 
 && 
 || 
 >> 
 << 
 += 
 -= 
 *= 
 /= 
 %= 
 &= 
 |= 
 ^= 
 <<= 
 >>= 
 ?: 



(5).可以表达式插入操作CPU部件和部分指令.

部件名称前面要加 "_",比如 "A = 0x97;" 要写成 "_A = 0x97;"

_NOP; //空操作

传送指令:

_A = 0x97; //立即数97H送A寄存器
_B = 0x52; //立即数52H送B寄存器
_A0 = 0x00; //立即数00H送A0寄存器
_A1 = 0xff; //立即数ffH送A1寄存器
_A2 = 0xe9; //立即数e9H送A2寄存器
_RAM = 0x3C; //立即数3cH送RAM/IO

_B = _A; //A寄存器数据送B寄存器
_A0 = _A; //A寄存器数据送A0寄存器
_A1 = _A; //A寄存器数据送A1寄存器
_A2 = _A; //A寄存器数据送A2寄存器
_RAM = _A; //A寄存器数据送RAM/IO

_A = _B; //B寄存器数据送A寄存器
_A0 = _B; //B寄存器数据送A0寄存器
_A1 = _B; //B寄存器数据送A1寄存器
_A2 = _B; //B寄存器数据送A2寄存器
_RAM = _B; //B寄存器数据送RAM/IO

_A = _RAM; //RAM/IO数据送A寄存器
_B = _RAM; //RAM/IO数据送B寄存器
_A0 = _RAM; //RAM/IO数据送A0寄存器
_A1 = _RAM; //RAM/IO数据送A1寄存器
_A2 = _RAM; //RAM/IO数据送A2寄存器


移位指令:

_A = _A << 1; //A寄存器数据带0左移1位送A寄存器
_B = _A << 1; //A寄存器数据带0左移1位送B寄存器
_A0 = _A << 1; //A寄存器数据带0左移1位送A0寄存器
_A1 = _A << 1; //A寄存器数据带0左移1位送A1寄存器
_A2 = _A << 1; //A寄存器数据带0左移1位送A2寄存器
_RAM = _A << 1; //A寄存器数据带0左移1位送RAM/IO

_A = _A_BH << 1; //A寄存器数据带B寄存器数据最高位左移1位送A寄存器
_B = _A_BH << 1; //A寄存器数据带B寄存器数据最高位左移1位送B寄存器
_A0 = _A_BH << 1; //A寄存器数据带B寄存器数据最高位左移1位送A0寄存器
_A1 = _A_BH << 1; //A寄存器数据带B寄存器数据最高位左移1位送A1寄存器
_A2 = _A_BH << 1; //A寄存器数据带B寄存器数据最高位左移1位送A2寄存器
_RAM = _A_BH << 1; //A寄存器数据带B寄存器数据最高位左移1位送RAM/IO

_A = _A_0 >> 1; //A寄存器数据带0右移1位送A寄存器
_B = _A_0 >> 1; //A寄存器数据带0右移1位送B寄存器
_A0 = _A_0 >> 1; //A寄存器数据带0右移1位送A0寄存器
_A1 = _A_0 >> 1; //A寄存器数据带0右移1位送A1寄存器
_A2 = _A_0 >> 1; //A寄存器数据带0右移1位送A2寄存器
_RAM = _A_0 >> 1; //A寄存器数据带0右移1位送RAM/IO

_A = _A >> 1; //A寄存器数据带最高位右移1位送A寄存器
_B = _A >> 1; //A寄存器数据带最高位右移1位送B寄存器
_A0 = _A >> 1; //A寄存器数据带最高位右移1位送A0寄存器
_A1 = _A >> 1; //A寄存器数据带最高位右移1位送A1寄存器
_A2 = _A >> 1; //A寄存器数据带最高位右移1位送A2寄存器
_RAM = _A >> 1; //A寄存器数据带最高位右移1位送RAM/IO


_A = _B << 1; //B寄存器数据带0左移1位送A寄存器
_B = _B << 1; //B寄存器数据带0左移1位送B寄存器
_A0 = _B << 1; //B寄存器数据带0左移1位送A0寄存器
_A1 = _B << 1; //B寄存器数据带0左移1位送A1寄存器
_A2 = _B << 1; //B寄存器数据带0左移1位送A2寄存器
_RAM = _B << 1; //B寄存器数据带0左移1位送RAM/IO

_A = _B_0 >> 1; //B寄存器数据带0右移1位送A寄存器
_B = _B_0 >> 1; //B寄存器数据带0右移1位送B寄存器
_A0 = _B_0 >> 1; //B寄存器数据带0右移1位送A0寄存器
_A1 = _B_0 >> 1; //B寄存器数据带0右移1位送A1寄存器
_A2 = _B_0 >> 1; //B寄存器数据带0右移1位送A2寄存器
_RAM = _B_0 >> 1; //B寄存器数据带0右移1位送RAM/IO

_A = _B >> 1; //B寄存器数据带最高位右移1位送A寄存器
_B = _B >> 1; //B寄存器数据带最高位右移1位送B寄存器
_A0 = _B >> 1; //B寄存器数据带最高位右移1位送A0寄存器
_A1 = _B >> 1; //B寄存器数据带最高位右移1位送A1寄存器
_A2 = _B >> 1; //B寄存器数据带最高位右移1位送A2寄存器
_RAM = _B >> 1; //B寄存器数据带最高位右移1位送RAM/IO

_A = _B_AL >> 1; //B寄存器数据带A寄存器数据最低位右移1位送A寄存器
_B = _B_AL >> 1; //B寄存器数据带A寄存器数据最低位右移1位送B寄存器
_A0 = _B_AL >> 1; //B寄存器数据带A寄存器数据最低位右移1位送A0寄存器
_A1 = _B_AL >> 1; //B寄存器数据带A寄存器数据最低位右移1位送A1寄存器
_A2 = _B_AL >> 1; //B寄存器数据带A寄存器数据最低位右移1位送A2寄存器
_RAM = _B_AL >> 1; //B寄存器数据带A寄存器数据最低位右移1位送RAM/IO


逻辑运算指令:

_A = _A & _B; //A寄存器数据和B寄存器数据按位与,结果送A寄存器
_B = _A & _B; //A寄存器数据和B寄存器数据按位与,结果送B寄存器
_A0 = _A & _B; //A寄存器数据和B寄存器数据按位与,结果送A0寄存器
_A1 = _A & _B; //A寄存器数据和B寄存器数据按位与,结果送A1寄存器
_A2 = _A & _B; //A寄存器数据和B寄存器数据按位与,结果送A2寄存器
_RAM = _A & _B; //A寄存器数据和B寄存器数据按位与,结果送RAM/IO

_A = _A | _B; //A寄存器数据和B寄存器数据按位或,结果送A寄存器
_B = _A | _B; //A寄存器数据和B寄存器数据按位或,结果送B寄存器
_A0 = _A | _B; //A寄存器数据和B寄存器数据按位或,结果送A0寄存器
_A1 = _A | _B; //A寄存器数据和B寄存器数据按位或,结果送A1寄存器
_A2 = _A | _B; //A寄存器数据和B寄存器数据按位或,结果送A2寄存器
_RAM = _A | _B; //A寄存器数据和B寄存器数据按位或,结果送送RAM/IO

_A = _A ^ _B; //A寄存器数据和B寄存器数据按位异或,结果送A寄存器
_B = _A ^ _B; //A寄存器数据和B寄存器数据按位异或,结果送B寄存器
_A0 = _A ^ _B; //A寄存器数据和B寄存器数据按位异或,结果送A0寄存器
_A1 = _A ^ _B; //A寄存器数据和B寄存器数据按位异或,结果送A1寄存器
_A2 = _A ^ _B; //A寄存器数据和B寄存器数据按位异或,结果送A2寄存器
_RAM = _A ^ _B; //A寄存器数据和B寄存器数据按位异或,结果送RAM/IO

_A =   ~ _A; //A寄存器数据取反送A寄存器
_B =   ~ _A; //A寄存器数据取反送B寄存器
_A0 =  ~ _A; //A寄存器数据取反送A0寄存器
_A1 =  ~ _A; //A寄存器数据取反送A1寄存器
_A2 =  ~ _A; //A寄存器数据取反送A2寄存器
_RAM = ~ _A; //A寄存器数据取反送RAM/IO

_A =   ~ _B; //B寄存器数据取反送A寄存器
_B =   ~ _B; //B寄存器数据取反送B寄存器
_A0 =  ~ _B; //B寄存器数据取反送A0寄存器
_A1 =  ~ _B; //B寄存器数据取反送A1寄存器
_A2 =  ~ _B; //B寄存器数据取反送A2寄存器
_RAM = ~ _B; //B寄存器数据取反送RAM/IO



算术运算指令:

_A = _A + _B; //A寄存器数据和B寄存器数据相加,结果送A寄存器
_B = _A + _B; //A寄存器数据和B寄存器数据相加,结果送B寄存器
_A0 = _A + _B; //A寄存器数据和B寄存器数据相加,结果送A0寄存器
_A1 = _A + _B; //A寄存器数据和B寄存器数据相加,结果送A1寄存器
_A2 = _A + _B; //A寄存器数据和B寄存器数据相加,结果送A2寄存器
_RAM = _A + _B; //A寄存器数据和B寄存器数据相加,结果送RAM/IO

_A = _A + 1; //A寄存器数据加1送A寄存器
_B = _A + 1; //A寄存器数据加1送B寄存器
_A0 = _A + 1; //A寄存器数据加1送A0寄存器
_A1 = _A + 1; //A寄存器数据加1送A1寄存器
_A2 = _A + 1; //A寄存器数据加1送A2寄存器
_RAM = _A + 1; //A寄存器数据加1送RAM/IO

_A = _A - _B; //A寄存器数据和B寄存器数据相减,结果送A寄存器
_B = _A - _B; //A寄存器数据和B寄存器数据相减,结果送B寄存器
_A0 = _A - _B; //A寄存器数据和B寄存器数据相减,结果送A0寄存器
_A1 = _A - _B; //A寄存器数据和B寄存器数据相减,结果送A1寄存器
_A2 = _A - _B; //A寄存器数据和B寄存器数据相减,结果送A2寄存器
_RAM = _A - _B; //A寄存器数据和B寄存器数据相减,结果送RAM/IO

_A = _A - 1; //A寄存器数据减1送A寄存器
_B = _A - 1; //A寄存器数据减1送B寄存器
_A0 = _A - 1; //A寄存器数据减1送A0寄存器
_A1 = _A - 1; //A寄存器数据减1送A1寄存器
_A2 = _A - 1; //A寄存器数据减1送A2寄存器
_RAM = _A - 1; //A寄存器数据减1送RAM/IO


寄存器比较:

_A > _B; //判断A寄存器数据大于B寄存器数据,输出真假值
_A < _B; //判断A寄存器数据小于B寄存器数据,输出真假值
_A >= _B; //判断A寄存器数据大于等于B寄存器数据,输出真假值
_A <= _B; //判断A寄存器数据小于等于B寄存器数据,输出真假值
_A == _B; //判断A寄存器数据等于B寄存器数据,输出真假值
_A != _B; //判断A寄存器数据不等于B寄存器数据,输出真假值

_AH == 1; //判断A寄存器数据最高位等于1,输出真假值
_AH != 1; //判断A寄存器数据最高位不等于1,输出真假值
_BH == 0; //判断B寄存器数据最高位等于0,输出真假值
_BH != 0; //判断B寄存器数据最高位不等于0,输出真假值

_ADD_A_B == 1; //判断A寄存器数据加B寄存器数据有进位，输出真假值
_ADD_A_B != 1; //判断A寄存器数据加B寄存器数据没有进位，输出真假值
_ADD_A_A == 1; //判断A寄存器数据加A寄存器数据有进位，输出真假值
_ADD_A_A != 1; //判断A寄存器数据加A寄存器数据没有进位，输出真假值
_ADD_A_1 == 1; //判断A寄存器数据加1有进位，输出真假值
_ADD_A_1 != 1; //判断A寄存器数据加1没有进位，输出真假值
_ADD_A_B_1 == 1; //判断A寄存器数据加B寄存器数据再加1有进位，输出真假值
_ADD_A_B_1 != 1; //判断A寄存器数据加B寄存器数据再加1没有进位，输出真假值
_ADD_A_A_1 == 1; //判断A寄存器数据加A寄存器数据再加1有进位，输出真假值
_ADD_A_A_1 != 1; //判断A寄存器数据加A寄存器数据再加1没有进位，输出真假值

_SUB_A_B == -1; //判断A寄存器数据减B寄存器数据有借位，输出真假值
_SUB_A_B != -1; //判断A寄存器数据减B寄存器数据没有借位，输出真假值
_SUB_A_1 == -1; //判断A寄存器数据加1有借位，输出真假值
_SUB_A_1 != -1; //判断A寄存器数据加1没有借位，输出真假值
_SUB_A_B_1 == -1; //判断A寄存器数据减B寄存器数据再减1有借位，输出真假值
_SUB_A_B_1 != -1; //判断A寄存器数据减B寄存器数据再减1没有借位，输出真假值





4.RAM内存布局和分配.

这里先粗略讲，细节过后再弄文档..


(1).变量起始分配地址.

注意 : 为了实现 "*a = b;" 这个操作，编译器屏蔽000000H~00FFFFH范围的RAM内存, 。。内存很多。禁掉64KB无伤大雅~。。;;;;;

所以变量从地址010000H开始分配;


(2).编译器运算中间结果内存分配.

其中编译器使用了010000H~010014H共21个字节固定作为运算中间结果的保存,包括函数返回值;

还有动态运算中间结果的保存,比如a = b + c + d, 假设4个变量都是char, 编译器会分解成如下的运算步骤,

A寄存器 = b + c;
a = A寄存器 + d;

可见b+c的中间结果是存在A寄存器,但是如果4个变量都是int,这里的A寄存器是8位，所以b+c的中间结果要存
回编译器动态分配的一个临时内存单元, 这个临时内存单元并不是010000H~010014H, 而是函数最后一个局部变量的地址延续，
其实就是隐藏的局部变量.



(3).局部变量分配.

函数之间有调用关系分配地址不同，函数之间没有调用关系，分配地址相同. 

下面这种调用关系的程序内存总占用约为1024字节. 
void a() 
{ 
  char x[1024]; 
} 

void b() 
{ 
  char x[1024]; 
} 

main() 
{ 
  a(); 
  b(); 
} 


而下面这种调用关系的程序内存总占用约为2048字节. 
void a() 
{ 
  char x[1024]; 
} 

void b() 
{ 
  char x[1024]; 
  a(); 
} 

main() 
{ 
  a(); 
  b(); 
} 







5.ROM内存布局和分配.

ROM地址000000H~000003H有一条跳转指令,是跳向000009H地址的,000004H~000008H装有一点东西..有5条指令,这5条指令执行会导致ROM控制器动作,
当CPU取到000008H地址的指令后，两组ROM的总线就会进行切换,然后CPU再取下一条指令就是另一组ROM的000009H地址的指令;
如果要执行ROM切换,只须执行 "rom_run;" 语句, 程序就会跳转到地址000004H;


KC-LS1u机的存储器有两组ROM指令存储器;
一组是EPROM,和BIOS一样上电运行,而且是只读存储器;
另一组是SROM(SRAM组成),通过执行切换指令来切换运行,这组ROM是映射到RAM内存地址的,在RAM内存地址范围是400000H~7FFFFFH,
其中400000H~5FFFFFH是指令低8位,600000H~7FFFFFH是指令高8位, 31e9H是一条CPU指令,如果要把这条指令放入SROM并运行要这样操作，
指令低8位e9H写入400009H内存单元,指令高8位31H写入600009H内存单元, 然后执行ROM切换指令;
要注意,EPROM这组ROM程序运行的时候SROM是映射到RAM内存单元, 当从EPROM切换到SROM运行之后,再操作RAM内存400000H~7FFFFFH是无效的;


000004H~000008H装有一点东西如下,

000004H : A2 = 0xc0;
000005H : A0 = 0x80;
000006H : NOP;
000007H : RAM = 0xff;
000008H : NOP;





